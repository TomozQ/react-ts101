# Reactにおけるコンポーネント
<br>

### JSXがブラウザで表示される仕組み
<hr>
JSXをwebpackがJavaScriptのコードに変換し、コンポーネントがJavaScriptのオブジェクトとして表現される。<br>
変換されたJavaScriptのコードをブラウザが読み込み・実行することで画面への描画が始まる。
<br>
<br>

### DOMアクセス
<hr>

#### Reactの描画エンジン
まず`仮想DOM`に構築する。
* 仮想DOM
<br>
メモリ上に保存された模式的なDOMツリー

前回構築した時の仮想DOMと比較し、差分があるところだけ実際のDOMを更新する。
<br>
変更が必要な部分だけ実際にDOMを更新することで、高速な描画を実現している。
<br>
<br>

### コンポーネント（Reactコンポーネント）
<hr>
Reactにおいてコンポーネントは見た目と振る舞いをセットにしたUIの部品の単位
現在は関数を使った関数コンポーネントを使用するのが主流
<br>
<br>

### React Hooks
<hr>

#### useState
useStateの戻り値は配列で、配列の1番目に現在の状態を保存する変数、2番目に更新関数が入っている。
```javascript
const [状態, 更新関数] = useState(初期状態)
```
* 更新関数を呼び出すと状態が変化し、フックがあるコンポーネントは再描画される。
* 更新関数を呼ぶには、引数に値を渡す方法と関数を渡す方法の２種類がある。値を渡した場合はその値が次の状態となり、関数を渡した場合は関数の戻り値が次の状態になる。また、その関数の引数には現在の状態が入っている。
<br>

#### useReducer
配列やオブジェクトなどの複数のデータをまとめたものを状態として扱う場合に用いられることが多い。useStateよりも複雑な用途に向いている。
```javascript
reducer (現在の状態, action){
  return 次の状態
}

const [現在の状態, dispatch] = useReducer(reducer, reducerに渡される初期状態)
```
* 更新関数（dispatch）にactionと呼ばれるデータを渡す。
* 現在の状態とactionを渡して次の状態を返すreducerという関数を用いる。
* `useReducer()`の戻り値の配列の1番目は現在の状態で、2番目がdispatch関数
* dispatch関数にactionを渡すことで状態を更新する。
* useStateのsetStateと比べ、状態の更新を呼び出す方は、具体的な状態に依存していないためコードをシンプルに保つこと
ができる。
* 状態を更新するロジックをコンポーネント外の関数に切り出しているため、テストが容易になる。

#### useCallback/useMemo
メモ化用のフック
* メモ化 ... ある関数の計算結果を保持し、同一の呼び出しがあった場合は保持しておいた結果を返すといった計算結果を再利用する最適化手法

値や関数を保持し、必要のない子要素のレンダリングや計算を抑制するために使用する。

```
Reactの再描画のタイミングとメモ化コンポーネントについて

Reactのコンポーネントは次のようなタイミングで再描画される
・propsや内部状態が更新された時
・コンポーネント内で参照しているContextの値が更新された時
・親コンポーネントが再描画された時

親コンポーネントが再描画されると子コンポーネントも無条件に描画される。このため上位のコンポーネントで再描画が発生すると、それ以下の全てのコンポーネントで再描画が発生する。
この再描画の伝搬を止めるのに、メモ化コンポーネントを使用する。

```
* メモ化コンポーネントは親コンポーネントで再描画が発生したとしても、propsやContextの値が変化しない場合は親コンポーネントによる再描画が発生しない。
* メモ化コンポーネントは関数コンポーネントをmemo関数でラップすると作成できる。

#### useCallback
* 関数をメモ化するためのフック
* useCallbackの第一引数は関数で、第二引数は依存配列。関数の再描画が行われるときに、useCallback()は依存配列の中の値を比較する。依存配列の中の値がそれぞれ前の描画時と同じものがあれば、現在の第一引数の仮数をメモに保存する。そのため、依存配列の中の値に異なるものがあるときは、新しい関数を返す。