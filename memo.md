# Reactにおけるコンポーネント
<br>

### JSXがブラウザで表示される仕組み
<hr>
JSXをwebpackがJavaScriptのコードに変換し、コンポーネントがJavaScriptのオブジェクトとして表現される。<br>
変換されたJavaScriptのコードをブラウザが読み込み・実行することで画面への描画が始まる。
<br>
<br>

### DOMアクセス
<hr>

#### Reactの描画エンジン
まず`仮想DOM`に構築する。
* 仮想DOM
<br>
メモリ上に保存された模式的なDOMツリー

前回構築した時の仮想DOMと比較し、差分があるところだけ実際のDOMを更新する。
<br>
変更が必要な部分だけ実際にDOMを更新することで、高速な描画を実現している。
<br>
<br>

### コンポーネント（Reactコンポーネント）
<hr>
Reactにおいてコンポーネントは見た目と振る舞いをセットにしたUIの部品の単位
現在は関数を使った関数コンポーネントを使用するのが主流
<br>
<br>

# React Hooks

## useState
useStateの戻り値は配列で、配列の1番目に現在の状態を保存する変数、2番目に更新関数が入っている。
```javascript
const [状態, 更新関数] = useState(初期状態)
```
* 更新関数を呼び出すと状態が変化し、フックがあるコンポーネントは再描画される。
* 更新関数を呼ぶには、引数に値を渡す方法と関数を渡す方法の２種類がある。値を渡した場合はその値が次の状態となり、関数を渡した場合は関数の戻り値が次の状態になる。また、その関数の引数には現在の状態が入っている。
<br>

## useReducer
配列やオブジェクトなどの複数のデータをまとめたものを状態として扱う場合に用いられることが多い。useStateよりも複雑な用途に向いている。
```javascript
reducer (現在の状態, action){
  return 次の状態
}

const [現在の状態, dispatch] = useReducer(reducer, reducerに渡される初期状態)
```
* 更新関数（dispatch）にactionと呼ばれるデータを渡す。
* 現在の状態とactionを渡して次の状態を返すreducerという関数を用いる。
* `useReducer()`の戻り値の配列の1番目は現在の状態で、2番目がdispatch関数
* dispatch関数にactionを渡すことで状態を更新する。
* useStateのsetStateと比べ、状態の更新を呼び出す方は、具体的な状態に依存していないためコードをシンプルに保つこと
ができる。
* 状態を更新するロジックをコンポーネント外の関数に切り出しているため、テストが容易になる。

## useCallback/useMemo
メモ化用のフック
* メモ化 ... ある関数の計算結果を保持し、同一の呼び出しがあった場合は保持しておいた結果を返すといった計算結果を再利用する最適化手法

値や関数を保持し、必要のない子要素のレンダリングや計算を抑制するために使用する。

```
Reactの再描画のタイミングとメモ化コンポーネントについて

Reactのコンポーネントは次のようなタイミングで再描画される
・propsや内部状態が更新された時
・コンポーネント内で参照しているContextの値が更新された時
・親コンポーネントが再描画された時

親コンポーネントが再描画されると子コンポーネントも無条件に描画される。このため上位のコンポーネントで再描画が発生すると、それ以下の全てのコンポーネントで再描画が発生する。
この再描画の伝搬を止めるのに、メモ化コンポーネントを使用する。

```
* メモ化コンポーネントは親コンポーネントで再描画が発生したとしても、propsやContextの値が変化しない場合は親コンポーネントによる再描画が発生しない。
* メモ化コンポーネントは関数コンポーネントをmemo関数でラップすると作成できる。

## useCallback
* 関数をメモ化するためのフック
* useCallbackの第一引数は関数で、第二引数は依存配列。
* 関数の再描画が行われる時に、useCallback()は依存配列の中の値を比較する。
* 依存配列の中の値がそれぞれ前の描画時と同じ場合は、useCallback()はメモ化している関数を返す。
* もし、依存配列の中の値で異なるものがあれば、現在の第一引数の関数をメモに保存する。そのため、依存配列の中の値に異なるものがある時は、新しい関数を返す。

## useMemo
値のメモ化を行う
* 第一引数は値を生成する関数を、第二引数には依存配列を渡す。
* useCallbackと同様にuseMemoはコンポーネントの描画時に依存配列を比較する。
* 依存配列の値が前の描画時と異なる場合は、関数を実行し、その結果を新しい値としてメモに保存する。

## useEffect/useLayoutEffect
副作用のためのフック
<br>
コンポーネントの描画とは直接関係のない処理
<br>
例) 

* 描画されたDOMを手動で変更
* ログを出力
* タイマーのセット
* データの取得

Reactにおいてはこの副作用を適切に管理することが重要

## useEffect
副作用を実行するために使用するフック
<br>
これらの処理をそのまま関数コンポーネントの中で実行すると、処理の中で参照しているDOMが描画により置き換わってしまったり、状態を更新してまた再描画が発生したり、無限ループになる可能性がある。

* useEffect()を使うと、propsやstateが更新され、再描画が終わった後に処理が実行される。
* 依存配列を指定することで、特定のデータが変化した時だけ処理を行うように設定できる。

## useLayoutEffect
useEffectと同じように副作用を実行するためのフックだが、実行されるタイミングが違う

* useEffect → 描画関数が実行し、DOMが更新され、画面に描画された後で実行
* useLayoutEffect → DOMが更新された後、画面に実際に描画される前に実行される。
* useLayoutEffectで実行する処理は同期的に実行されるため、重い処理を実行すると画面への描画が遅れるので注意する必要がある。

<br>
<br>

<hr>

## React18におけるuseEffect・useLayoutEffectの挙動

```<React.StrictMode>```以下のコンポーネント内で宣言されたuseEffect, useLayoutEffectは安全でない副作用を見つけるためにコンポーネントは2回描画される。
そのため、空配列を渡した場合において、マウント時にuseEffectやuseLayoutEffectが2回呼ばれる。また、クリーンアップ関数も1回呼ばれることになる。1回のみの実行を保証したい場合は、useRefなどを使って前に実行されたかどうかを保持することで対処できる。
なお本番環境や<React.StrictMode>で囲まれていないコンポーネントに関しては、この挙動は発生しない。

```javascript
const mounted = React.useRef(false)

useEffect(() => {
  if(mounted.current){
    // すでに実行済みの場合は何もしない
    return
  }
  mounted.current = true

  // 1回だけ実行したい副作用の実行
  const data = fetch(...)
},[])
```
<hr>

<br>
<br>

## useContext
Contextから値を参照するためのフック
<br>
useContextの引数にContextを渡すことで、そのContextの値を取得できる。

## useRef
書き換え可能なrefオブジェクト
### refの使い型
1. データの保持
2. DOMの参照

### データの保持
useState / useReducer → 状態を更新するたびに再描画が発生する。<br>
<br>
refオブジェクト → 更新しても再描画が発生しない。
<br>
→描画に関係ないデータを保持するのに使用される。
<br>
`ref.current`から読み出したり書き換えたりする。

### DOMの参照
`ref`をコンポーネントに渡すと、この要素がマウントされた時、`ref.current`にDOMの参照がセットされ、DOMの関数などを呼び出すことができる。

<br>
<br>

## useImperativeHandle
* コンポーネントにrefが渡された時に、親のrefに代入される値を設定する
* 子コンポーネントが持つデータを参照したり、子コンポーネントで定義されている関数を親から呼んだりできる。

`useImperativeHandle`を使うことで、コンポーネントの関数を親から好きなタイミングで明示的に呼び出せる。しかし、親コンポーネントが子コンポーネントに依存しているため、あまり頻繁には使われない。多くの場合はpropsで代用できる。
<br>
<br>


## カスタムフック
* フックを使用する関数を新たに定義して、それを関数コンポーネントのトップレベルで呼び出すことができる。
